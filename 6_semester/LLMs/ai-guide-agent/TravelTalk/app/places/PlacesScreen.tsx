import React, { useState, useEffect, useRef, useCallback } from "react";
import {
    View,
    ActivityIndicator,
    Animated,
    LayoutChangeEvent,
    StyleSheet,
    Text,
    TouchableWithoutFeedback,
    TouchableOpacity, Platform
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { BlurView } from "expo-blur";
import * as Location from "expo-location";
import { PlacesList } from "./PlacesList";
import { SearchBar } from "./SearchBar";
import { NavigationHeader, NavigationHeaderRef } from "./NavigationHeader";
import { CategoryTabs } from "./CategoryTabs";
import { Place } from "./types/PlaceTypes";
import { Toolbar } from "@/app/places/Toolbar";
import {MapType} from "@/app/places/types/MapTypes";
import {UserInterfaceStyle} from "@/app/places/types/UserInterfaceStyle";
import i18n from "@/config/i18n";
import MapView, {Callout, Marker} from "react-native-maps";

import {
    getFirestore,
    collection,
    addDoc,
    serverTimestamp,
    where,
    getDocs,
    query,
    Timestamp,
    orderBy, limit
} from 'firebase/firestore';
import { FIREBASE_AUTH, firestore } from '@/config/firebase';
import { getAuth } from "firebase/auth";
import { Audio } from 'expo-av';
import {TimelineSegment} from "@/app/utils/audio/declarations";
import {Ionicons} from "@expo/vector-icons";
import { TextNowPlayingWidget } from "./widget/TextNowPlayingWidget";
import { SlidingPanelNowPlaying } from "./widget/SlidingPanelNowPlaying";


const GOOGLE_MAPS_API_KEY = process.env.EXPO_PUBLIC_GOOGLE_MAPS_API_KEY;

export const PlacesScreen = () => {
    const [location, setLocation] = useState<Location.LocationObject | null>(null);
    const [places, setPlaces] = useState<Place[]>([]);
    const [pastPlaces, setPastPlaces] = useState<Place[]>([]);
    const [filteredPlaces, setFilteredPlaces] = useState<Place[]>([]);
    const [filteredPastPlaces, setFilteredPastPlaces] = useState<Place[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [isLoadingHistory, setIsLoadingHistory] = useState(false);
    const [activeTab, setActiveTab] = useState<"near" |"history">("near");

    const [language, setLanguage] = useState(i18n.language);
    const [mapType, setMapType] = useState<MapType>(MapType.Standard);
    const [userInterfaceStyle, setUserInterfaceStyle] = useState<UserInterfaceStyle>(UserInterfaceStyle.Light);
    const [radius, setRadius] = useState<number>(1500); // Default radius
    const [region, setRegion] = useState({
        latitude: 0,
        longitude: 0,
        latitudeDelta: 0.005,
        longitudeDelta: 0.005,
    });
    const mapRef = useRef<MapView | null>(null); // Reference to the map
    const navHeaderRef = useRef< NavigationHeaderRef | null>(null);
    const [sound, setSound] = useState<Audio.Sound | null>(null);
    const [timeline, setTimeline] = useState<TimelineSegment[]>([]);
    const [isPlaying, setIsPlaying] = useState(false); // Track whether the audio is playing
    const [audioPosition, setAudioPosition] = useState(0); // Store the current position    
    const [useLLMBackend, setUseLLMBackend] = useState(true); // or true for LLM backend
    // const backendUrl = "your api url generated by ngrok";
    const backendUrl = "https://36b0-2a02-2f0e-70b-ad00-f987-1433-90c2-f2f2.ngrok-free.app";

    // Flag to track if we've already fetched places
    const initialFetchDone = useRef(false);
    // Store the last parameters used for fetching
    const lastFetchParams = useRef({ language: language, radius: radius });

    // Add state for now playing widget/modal
    const [showNowPlayingModal, setShowNowPlayingModal] = useState(false);
    const [nowPlayingTitle, setNowPlayingTitle] = useState<string | null>(null);
    const [nowPlayingText, setNowPlayingText] = useState<string | null>(null);
    // Add state for pending navigation action
    const [pendingNavAction, setPendingNavAction] = useState<null | (() => void)>(null);

    // Add fade animation state
    const fadeAnim = useRef(new Animated.Value(0)).current;

    useEffect(() => {
        if (nowPlayingTitle) {
            Animated.timing(fadeAnim, {
                toValue: 1,
                duration: 400,
                useNativeDriver: true,
            }).start();
        } else {
            Animated.timing(fadeAnim, {
                toValue: 0,
                duration: 200,
                useNativeDriver: true,
            }).start();
        }
    }, [nowPlayingTitle]);

    // Memoize fetchNearbyPlaces to prevent recreation on every render
    const fetchNearbyPlaces = useCallback(async (userLocation: Location.LocationObject, fetchLang: string, fetchRadius: number) => {
        setIsLoading(true);
        console.log("Fetching nearby places");
        try {
            const { latitude, longitude } = userLocation.coords;
            const response = await fetch(
                `https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=${latitude},${longitude}&radius=${fetchRadius}&type=tourist_attraction&language=${fetchLang}&key=${GOOGLE_MAPS_API_KEY}`
            );
            const data = await response.json();
            if (data.results) {
                const formattedPlaces: Place[] = data.results.map((place: any) => {
                    const photoReference = place.photos?.[0]?.photo_reference;
                    const imageUrl = photoReference
                        ? `https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photoreference=${photoReference}&key=${GOOGLE_MAPS_API_KEY}`
                        : require('../../assets/images/no-image.png');
                    return {
                        id: place.place_id,
                        name: place.name,
                        image: imageUrl,
                        distance: calculateDistance(
                            latitude,
                            longitude,
                            place.geometry.location.lat,
                            place.geometry.location.lng
                        ).toFixed(1),
                        coordinate: {
                            latitude: place.geometry.location.lat,
                            longitude: place.geometry.location.lng,
                        },
                        vicinity: place.vicinity,
                    };
                });

                const sortedPlaces = formattedPlaces.sort((a, b) => a.distance - b.distance);
                setPlaces(sortedPlaces);
                setFilteredPlaces(sortedPlaces);
            }
        } catch (error) {
            console.error("Failed to fetch places:", error);
        } finally {
            setIsLoading(false);
        }
    }, []);

    // Split initialization and fetch logic
    useEffect(() => {
        const initializeLocation = async () => {
            let { status } = await Location.requestForegroundPermissionsAsync();
            if (status !== 'granted') {
                console.log("Location permission not granted");
                return;
            }

            let currentLocation = await Location.getCurrentPositionAsync({});
            setLocation(currentLocation);
            
            // Only set initial region if it hasn't been set yet
            if (region.latitude === 0 && region.longitude === 0) {
            setRegion({
                latitude: currentLocation.coords.latitude,
                longitude: currentLocation.coords.longitude,
                latitudeDelta: 0.005,
                longitudeDelta: 0.005,
            });
            }

            // Initial fetch on first mount only
            if (!initialFetchDone.current) {
                fetchNearbyPlaces(currentLocation, language, radius);
                fetchPastPlaces(currentLocation);
                initialFetchDone.current = true;
                lastFetchParams.current = { language, radius };
            }
        };

        initializeLocation();
    }, []); // Empty dependency array means this only runs once

    // Separate effect for handling language/radius changes
    useEffect(() => {
        // Skip if we haven't fetched location yet
        if (!location) return;
        
        // Only fetch if language or radius has actually changed from the last fetch
        if (language !== lastFetchParams.current.language || radius !== lastFetchParams.current.radius) {
            console.log("Parameters changed, fetching new places");
            fetchNearbyPlaces(location, language, radius);
            lastFetchParams.current = { language, radius };
        }
    }, [language, radius, location, fetchNearbyPlaces]);
    
    useEffect(() => {
        if( timeline.length > 0 && nowPlayingTitle && !useLLMBackend) {
            console.log("Timeline updated")
            const textContent = timeline.map((seg: TimelineSegment) => seg.sequence).join(" ");
            console.log(textContent)
            setNowPlayingText(textContent);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [timeline, useLLMBackend, nowPlayingTitle]);

    const fetchPastPlaces = async (userLocation : Location.LocationObject) => {
        setIsLoadingHistory(true);
        const user = getAuth().currentUser;
        const email = user ? user.email : null;

        if (!email) {
            console.log("No user is logged in.");
            setIsLoadingHistory(false);
            return [];
        }

        try {
            // Create a reference to the 'visited_places' collection
            const placesCollectionRef = collection(firestore, 'places_history');

            // Query the collection to get documents where the 'email' field matches the current user's email
            const q = query(
                placesCollectionRef,
                where("user_email", "==", email),
                orderBy("timestamp", "desc"), // Order by timestamp, most recent first
                limit(15) // Limit the query to the last 15 places
            );
            // Get the documents that match the query
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                console.log("No places found for this user.");
                setIsLoadingHistory(false);
                return [];
            }

            // Process the documents
            const places: Place[] = querySnapshot.docs.map((doc) => {
                const place: any = doc.data();

                const imageUrl = place.place_image || "default-image-url"; // Set a default image URL if not available

                const timestamp = place.timestamp as Timestamp;
                return {
                    id: timestamp.toMillis().toString(),
                    name: place.place_name,
                    image: imageUrl,
                    distance: Number(calculateDistance(
                        userLocation.coords.latitude,
                        userLocation.coords.longitude,
                        place.location.latitude,
                        place.location.longitude
                    ).toFixed(1)),
                    coordinate: {
                        latitude: place.location.latitude,
                        longitude: place.location.longitude,
                    },
                    vicinity: place.vicinity,
                };
            });

            // Return the retrieved places
            const sortedPlaces = places.sort((a, b) => parseInt(b.id) - parseInt(a.id));
            setPastPlaces(sortedPlaces);
            setFilteredPastPlaces(sortedPlaces);
        } catch (error) {
            console.error("Error fetching places from Firestore:", error);
        } finally {
            setIsLoadingHistory(false);
        }
    }

    const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number) => {
        const toRad = (value: number) => (value * Math.PI) / 180;
        const R = 6371;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    };

    const handleSearch = (query: string) => {
        if (query.trim() === "") {
                setFilteredPlaces(places);
                setFilteredPastPlaces(pastPlaces);

        } else {
                const filtered = places.filter((place) => place.name.toLowerCase().includes(query.toLowerCase()));
                setFilteredPlaces(filtered);
                const filteredPast = pastPlaces.filter((place) => place.name.toLowerCase().includes(query.toLowerCase()));
                setFilteredPastPlaces(filteredPast);
            }
    };

    const [isContentVisible, setIsContentVisible] = useState(false);
    const contentOpacity = useRef(new Animated.Value(0)).current;
    const [headerHeight, setHeaderHeight] = useState(0);

    const handleHeaderLayout = (event: LayoutChangeEvent) => {
        const { height } = event.nativeEvent.layout;
        setHeaderHeight(height);
    };

    const [isToolbarVisible, setIsToolbarVisible] = useState(false);

    const toggleContent = () => {
        Animated.timing(contentOpacity, {
            toValue: isContentVisible ? 0 : 1,
            duration: 300,
            useNativeDriver: true,
        }).start();
        setIsContentVisible((prev) => !prev);
    };

    const toggleToolbar = () => {
        setIsToolbarVisible((prev) => !prev);
    };

    // Navigation action handler: closes panel first if open, then runs action
    const handleNavAction = (action: () => void) => {
      if (showNowPlayingModal) {
        setShowNowPlayingModal(false);
        setPendingNavAction(() => action);
      } else {
        action();
      }
    };

    const handleLanguageChange = useCallback((newLanguage: string) => {
        setLanguage(newLanguage);
    }, []);

    const handleRadiusChange = useCallback((newRadius: number) => {
        setRadius(newRadius);
    }, []);

    const handleMapTypeChange = useCallback((type: MapType) => {
        setMapType(type);
    }, []);

    const handleUserInterfaceStyleChange = useCallback((style: UserInterfaceStyle) => {
        setUserInterfaceStyle(style);
    }, []);

    if (!location) {
        return (
            <View className="flex-1 justify-center items-center">
                <ActivityIndicator size="large" color="#ef4444" />
            </View>
        );
    }

    const focusOnNewPlace = async (place: Place) => {
        // Focus on the place first
        focusOnPlace(place);

        const user = FIREBASE_AUTH.currentUser;
        const email = user ? user.email : null;

        if (email && user) {
            try {
                // Check if there's an existing chat for this place
                const messagesRef = collection(firestore, 'chat_messages');
                const q = query(
                    messagesRef,
                    where('placeName', '==', place.name),
                    where('userId', '==', user.uid),
                    limit(1)
                );

                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {

                // Save the place data to Firestore
                    const placesCollectionRef = collection(firestore, 'places_history');
                    await addDoc(placesCollectionRef, {
                        place_id: place.id,
                        place_name: place.name,
                        place_image: place.image,
                        location: {
                            latitude: place.coordinate.latitude,
                            longitude: place.coordinate.longitude,
                        },
                        user_email: email,
                        timestamp: serverTimestamp(),
                        vicinity: place.vicinity,
                    });


                // Only generate new text if there's no existing chat
                    setNowPlayingTitle(place.name);
                    setNowPlayingText(null);

                    if (useLLMBackend) {
                        const data = await fetchLLMSummary(place);
                        if (data) {
                            setNowPlayingText(data);
                            await fetchTTSFromSummary(data);
                            playSound();
                        }
                    } else {
                        await fetchTTSTimeline(place);
                        playSound();
                    }
                } else {
                    console.log("Chat exists, just setting the title and showing the chat");
                    // If chat exists, just set the title and show the chat
                    setNowPlayingTitle(place.name);
                    setNowPlayingText(null);
                }
            } catch (error) {
                console.error("Error in focusOnNewPlace:", error);
            }
        } else {
            console.log("No user is logged in.");
        }

        fetchPastPlaces(location);
    };

        // New function to focus the map on a selected place
        const focusOnPlace = async (place: Place) => {
            if (mapRef.current) {
                navHeaderRef.current?.triggerGoBack();
                mapRef.current.animateToRegion(
                    {
                        latitude: place.coordinate.latitude,
                        longitude: place.coordinate.longitude,
                        latitudeDelta: 0.005,
                        longitudeDelta: 0.005,
                    },
                    1000
                );
            }
        };
    
    // New function: fetchNearbyPlacesLLM
    const fetchLLMSummary = async (place: Place) => {
        console.log('Fetching LLM summary for:', place.name);
        try {
            const response = await fetch(backendUrl + '/api/llm_summary', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    place_name: place.name,
                    place_vicinity: place.vicinity,
                    language: language,
                }),
            });
            if (!response.ok) throw new Error('Failed to fetch LLM summary');
            const data = await response.json();
            setTimeline(data.summary)
            return data.summary;
        } catch (error) {
            // Fallback: use a local summary or mock
            return null;
        }
    };
    
    const fetchTTSTimeline = async (place: Place) => {
        try {
            const response = await fetch('/api/deepgram_tts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    text: '',
                    generate: true,
                    prompt: `Provide a brief summary (maximum 2-3 sentences) about ${place.name} located in ${place.vicinity}. 
                    Describe if notable the history, general atmosphere, local culture, and any other features that make the place unique. 
                    Keep the response concise but informative. Provide an answer similar but VERY IMPORTANT, 
                    NOT the same as "Information about ${place.name} located in ${place.vicinity} not found." 
                    
                    ONLY IF ABSOLUTELY no information is not found AT ALL but if something at all is found then return the brief (maximum 2-3 sentences) summary 
                    based on that. Provide the information in the language: ${language}`,
                }),
            });

            if (!response.ok) throw new Error('Failed to fetch TTS timeline');
            const timelineData = await response.json();
            console.log('TTS timeline:', timelineData);
            setTimeline(timelineData);
        } catch (error) {
            console.error('Error fetching TTS timeline:', error);
        }
    };

    const fetchTTSFromSummary = async (summary: string) => {
        console.log("summary", summary)
        try {
            const response = await fetch('/api/deepgram_tts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    text: summary,
                    generate: false, // or true if your API expects it
                }),
            });
            if (!response.ok) throw new Error('Failed to generate TTS');   
        
            // Optionally handle response
        } catch (error) {
            console.error('Error generating TTS:', error);
        }
    };

    const playSound = async () => {
        try {
            if (sound) {
                await sound.unloadAsync(); // Unload the previous sound
            }

            const { sound: newSound } = await Audio.Sound.createAsync(
                require('../../assets/output.mp3'), // Adjust the path to your file
            {},
            onPlaybackStatusUpdate
            );

            setSound(newSound);
            await newSound.playAsync(); // Play the audio
            setIsPlaying(true); // Update state to reflect that audio is playing

        } catch (error) {
            console.error('Error playing sound:', error);
        }
    };

    const toggleAudio = async () => {
        if(sound){
        if (isPlaying) {
            // Pause the audio and store the current position
            const status = await sound.getStatusAsync();
            if(status.isLoaded){
                setAudioPosition(status.positionMillis);
                await sound.pauseAsync();
            }
        } else {
            // Play the audio from the stored position (or start from the beginning)
            sound.playFromPositionAsync(audioPosition).catch(error => console.log(error));
        }
        setIsPlaying(!isPlaying);
        }};

    // Define the onPlaybackStatusUpdate method
    const onPlaybackStatusUpdate = (status: any) => {
        if (status.isLoaded) {
            if (status.didJustFinish) {
                setIsPlaying(false); // Audio finished, update state
                setAudioPosition(0); // Reset position if audio ends
            } else if (status.positionMillis !== audioPosition) {
                setAudioPosition(status.positionMillis); // Update position
            }
        }
    };

    return (
        <TouchableWithoutFeedback
            onPress={() => {
                if (isToolbarVisible) {
                    navHeaderRef.current?.triggerSettingsPress();
                }
            }}
        >
        <SafeAreaView className="flex-1 bg-white">
            <MapView
                ref={mapRef}
                style={StyleSheet.absoluteFillObject}
                initialRegion={{
                    latitude: location.coords.latitude,
                    longitude: location.coords.longitude,
                    latitudeDelta: 0.005,
                    longitudeDelta: 0.005,
                }}
                region={region}
                showsUserLocation={true}
                userInterfaceStyle={userInterfaceStyle}
                mapType={mapType}
                showsCompass={false}
                zoomEnabled={true} // Enables pinch-to-zoom gestures
                zoomControlEnabled={false}
                customMapStyle={userInterfaceStyle === UserInterfaceStyle.Dark ? mapCustomStyle : []}
            >
                {places.map((place) => (
                    <Marker.Animated key={place.id} coordinate={place.coordinate} title={place.name} description={place.vicinity}>
                        <Callout>
                            <View className="w-40 p-2">
                                <Text className="font-bold">{place.name}</Text>
                                <Text className="text-gray-600">{place.vicinity}</Text>
                            </View>
                        </Callout>
                    </Marker.Animated>
                ))}
            </MapView>

            <View onLayout={handleHeaderLayout} className="absolute inset-x-0 top-0 z-10">
                <View className="mt-16">
                    <NavigationHeader
                      ref={navHeaderRef}
                      onBackPress={() => handleNavAction(toggleContent)}
                      onSettingsPress={() => handleNavAction(toggleToolbar)}
                    />
                </View>
            </View>

            <Animated.View className="absolute inset-0 top-0 left-0 right-0 bottom-0" style={{ opacity: contentOpacity }}     pointerEvents={isContentVisible ? "auto" : "none"}>
                <BlurView intensity={50} className="flex-1">
                    <View style={{ top: 0, marginTop: headerHeight, left: 0, right: 0 }} className="mt-0">
                        <CategoryTabs activeTab={activeTab} setActiveTab={setActiveTab} />
                    </View>
                    {activeTab === "near" && <PlacesList places={filteredPlaces} isLoading={isLoading} onPlacePress={focusOnNewPlace}/>}
                    {activeTab === "history" && (
                      <PlacesList 
                        places={filteredPastPlaces} 
                        isLoading={isLoadingHistory} 
                        onPlacePress={focusOnPlace}
                      />
                    )}
                    <SearchBar onSearch={handleSearch} />
                </BlurView>
            </Animated.View>

          <Toolbar
              isVisible={isToolbarVisible}
              onChangeLanguage={handleLanguageChange}
              onChangeMapType={handleMapTypeChange}
              onChangeUserInterfaceStyle={handleUserInterfaceStyleChange}
              onChangeRadius={handleRadiusChange} // Pass radius handler
          />
            
            {!isContentVisible && !isToolbarVisible && nowPlayingTitle && (
                <Animated.View style={{
                    opacity: fadeAnim,
                    flexDirection: 'row',
                    alignItems: 'center',
                    justifyContent: 'center',
                    position: 'absolute',
                    alignSelf: 'center',
                    bottom: 0,
                    width: 'auto',
                    marginBottom: 64,
                }}>
                    <View style={{ flex: 0.90, marginLeft: 12, marginRight: 12, borderRadius: 30, overflow: 'hidden', minHeight: 60 }}>
                        <TextNowPlayingWidget
                            title={nowPlayingTitle}
                            onPress={() => setShowNowPlayingModal(true)}
                        />
                    </View>
                    <BlurView intensity={50} tint="dark" style={{ borderRadius: 25, overflow: 'hidden' }}>
                        <TouchableOpacity
                            style={{ width: 56, height: 56, borderRadius: 28, alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }}
                            onPress={toggleAudio}
                            disabled={!sound}
                            activeOpacity={0.85}
                        >
                            <Ionicons
                                name={isPlaying ? "pause" : "play"}
                                size={28}
                                color="#222"
                            />
                        </TouchableOpacity>
                    </BlurView>
                </Animated.View>
            )}
            <SlidingPanelNowPlaying
                visible={showNowPlayingModal}
                onClose={() => {
                  setShowNowPlayingModal(false);
                  if (pendingNavAction) {
                    pendingNavAction();
                    setPendingNavAction(null);
                  }
                }}
                title={nowPlayingTitle}
                text={nowPlayingText}
                backendUrl={backendUrl}
                language={language}
            />
        </SafeAreaView>
        </TouchableWithoutFeedback>
    );
};

const mapCustomStyle = [
    {
        elementType: "geometry",
        stylers: [{ color: "#242f3e" }],
    },
    {
        elementType: "labels.text.fill",
        stylers: [{ color: "#746855" }],
    },
    {
        elementType: "labels.text.stroke",
        stylers: [{ color: "#242f3e" }],
    },
    {
        featureType: "administrative.locality",
        elementType: "labels.text.fill",
        stylers: [{ color: "#d59563" }],
    },
    {
        featureType: "poi",
        elementType: "labels.text.fill",
        stylers: [{ color: "#d59563" }],
    },
    {
        featureType: "poi.park",
        elementType: "geometry",
        stylers: [{ color: "#263c3f" }],
    },
    {
        featureType: "poi.park",
        elementType: "labels.text.fill",
        stylers: [{ color: "#6b9a76" }],
    },
    {
        featureType: "road",
        elementType: "geometry",
        stylers: [{ color: "#38414e" }],
    },
    {
        featureType: "road",
        elementType: "geometry.stroke",
        stylers: [{ color: "#212a37" }],
    },
    {
        featureType: "road",
        elementType: "labels.text.fill",
        stylers: [{ color: "#9ca5b3" }],
    },
    {
        featureType: "road.highway",
        elementType: "geometry",
        stylers: [{ color: "#746855" }],
    },
    {
        featureType: "road.highway",
        elementType: "geometry.stroke",
        stylers: [{ color: "#1f2835" }],
    },
    {
        featureType: "road.highway",
        elementType: "labels.text.fill",
        stylers: [{ color: "#f3d19c" }],
    },
    {
        featureType: "transit",
        elementType: "geometry",
        stylers: [{ color: "#2f3948" }],
    },
    {
        featureType: "transit.station",
        elementType: "labels.text.fill",
        stylers: [{ color: "#d59563" }],
    },
    {
        featureType: "water",
        elementType: "geometry",
        stylers: [{ color: "#17263c" }],
    },
    {
        featureType: "water",
        elementType: "labels.text.fill",
        stylers: [{ color: "#515c6d" }],
    },
    {
        featureType: "water",
        elementType: "labels.text.stroke",
        stylers: [{ color: "#17263c" }],
    },
]